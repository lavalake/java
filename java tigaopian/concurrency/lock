https://www.cnblogs.com/chenssy/p/4718597.html
java多线程的可重入性的实现是通过每个锁关联一个请求计算和一个占有它的线程，当计数为0时，认为该锁是没有被占有的，那么任何线程都可以获得该锁的占有权。
当某一个线程请求成功后，JVM会记录该锁的持有线程 并且将计数设置为1，如果这时其他线程请求该锁时则必须等待。当该线程再次请求请求获得锁时，计数会+1；
当占有线程退出同步代码块时，计数就会-1，直到为0时，释放该锁。这时其他线程才有机会获得该锁的占有权

ReentrantLock：一个可重入的互斥锁，为lock接口的主要实现。

ReentrantReadWriteLock：

ReadWriteLock：ReadWriteLock 维护了一对相关的锁，一个用于只读操作，另一个用于写入操作。

Semaphore：一个计数信号量。

Condition:锁的关联条件，目的是允许线程获取锁并且查看等待的某一个条件是否满足。

CyclicBarrier：一个同步辅助类，它允许一组线程互相等待，直到到达某个公共屏障点。

ReentrantLock 将由最近成功获得锁定，并且还没有释放该锁定的线程所拥有。当锁定没有被另一个线程所拥有时，调用 lock 的线程将成功获取该锁定并返回。
如果当前线程已经拥有该锁定，此方法将立即返回。可以使用 isHeldByCurrentThread() 和 getHoldCount() 方法来检查此情况是否发生。
ReentrantLock提供公平锁机制，构造方法接收一个可选的公平参数。当设置为true时，它是公平锁，这些所将访问权授予等待时间最长的线程。
否则该锁将无法保证线程获取锁的访问顺序。但是公平锁与非公平锁相比，公平锁的程序在许多线程访问时表现为很低的总体吞吐量。
